!function(){"use strict";const t="FETCH_DATA",e="temperature",n="precipitation";const o=t=>t;function a(t,e=o){return function(...n){return{type:t,payload:e(...n)}}}const r=a("ERROR",(t,e="Something bad happened in worker")=>({error:t,message:e})),s=a("RECIEVE_DATA",(t,e,n)=>({route:t,data:n,code:e}));function c(t){return new Promise((e,n)=>{t.onsuccess=(()=>e(t.result)),t.onerror=n})}self.dbPromise=async function(){return new Promise((t,o)=>{const a=indexedDB.open("weather_app",1);a.onupgradeneeded=function(t){const o=t.target.result;o.createObjectStore(e,{keyPath:"t"}),o.createObjectStore(n,{keyPath:"t"})},a.onsuccess=function(e){t(e.target.result)},a.onerror=function(t){o(t)}})}(),console.log("Worker installed"),self.onmessage=function(o){try{const{data:a}=o;switch(a.type){case t:!async function({route:t,params:o}){switch(t){case e:case n:try{const e=await self.dbPromise;let n=e.transaction(t,"readonly").objectStore(t);const a=await c(n.count());if(!a){const o=await fetch(`./data/${t}.json`),a=await o.json();n=e.transaction(t,"readwrite").objectStore(t),a.forEach(t=>{n.add(t)})}n=e.transaction(t,"readonly").objectStore(t);const r=await c(n.getAll(function({start_date:t,end_date:e}){return IDBKeyRange.bound(`${t}-01-01`,`${e}-12-12`)}(o)));self.postMessage(s(t,200,function(t,e=12){return t.slice(0,e)}(r)))}catch(t){console.error(t)}}}(a.payload);break;default:throw"Unknown data type"}}catch(t){self.postMessage(r(t))}}}();
